---
name: prompt-enhancer
description: 사용자의 컨텍스트와 프로젝트 상태를 분석하여 초보 개발자 수준의 요청을 시니어 개발자 품질의 프롬프트로 변환합니다. 사용자의 의도를 유지하면서 명확성, 구체성, 기술적 정확성을 향상시킵니다.
---

# Claude Code를 위한 프롬프트 개선기

## 목적

이 스킬은 다음을 통해 사용자 요청을 최적화된 시니어 수준의 개발 프롬프트로 변환합니다:
- 현재 프로젝트 컨텍스트 및 파일 구조 분석
- 누락된 기술적 세부사항 식별
- 관련 제약사항 및 모범 사례 추가
- 최적의 Claude Code 실행을 위한 요청 구조화

## 활성화 시점

다음과 같은 사용자 요청 시 이 스킬을 실행합니다:
- 기술적 구체성이 부족한 경우
- 구현 세부사항이 모호하거나 불명확한 경우
- 파일 위치, 종속성 또는 아키텍처에 대한 컨텍스트가 누락된 경우
- 구조화된 세분화가 도움이 될 경우
- 범위나 제약사항에 대한 명확화가 필요한 경우

## 핵심 분석 프로세스

### 1. 컨텍스트 수집 단계

프롬프트를 개선하기 전에 다음 확인을 수행합니다:

```bash
# 현재 디렉토리 구조 확인
ls -la

# 프로젝트 타입 식별
if [ -f "package.json" ]; then echo "Node.js 프로젝트 감지됨"
elif [ -f "requirements.txt" ] || [ -f "pyproject.toml" ]; then echo "Python 프로젝트 감지됨"
elif [ -f "Cargo.toml" ]; then echo "Rust 프로젝트 감지됨"
elif [ -f "go.mod" ]; then echo "Go 프로젝트 감지됨"
fi

# git 상태 확인 (가능한 경우)
git status 2>/dev/null || echo "git 저장소가 아님"

# 최근 파일 확인
ls -lt | head -10
```

### 2. 요청 분석 프레임워크

각 사용자 요청에 대해 다음을 추출합니다:

**A. 의도 분류**
- 생성: 새 파일, 기능, 컴포넌트
- 수정: 리팩토링, 버그 수정, 업데이트
- 분석: 코드 리뷰, 디버깅, 최적화
- 문서화: 주석, README, API 문서

**B. 기술적 범위**
- 사용되는 언어/프레임워크
- 파일 위치 및 종속성
- 예상되는 아키텍처 패턴
- 테스트 요구사항
- 성능 제약사항

**C. 누락된 정보**
- 정의되지 않은 변수명 또는 규칙
- 불명확한 데이터 구조
- 누락된 에러 처리 요구사항
- 명시되지 않은 엣지 케이스
- 모호한 성공 기준

### 3. 개선 전략

#### 전략 1: 구체성 주입

**개선 전:**
"앱에 인증 추가해줘"

**개선 후:**
```
다음 요구사항으로 Express.js API에 JWT 기반 인증을 구현하세요:

1. `src/middleware/auth.js`에 미들웨어 생성:
   - Authorization 헤더에서 JWT 토큰 확인
   - 토큰 만료 검증
   - req.user에 사용자 페이로드 첨부
   - 유효하지 않거나 누락된 토큰에 대해 401 반환

2. `src/routes/auth.js`에 인증 엔드포인트 추가:
   - POST /api/auth/login (email, password) → JWT 반환
   - POST /api/auth/refresh → 새 JWT 반환
   - POST /api/auth/logout → 리프레시 토큰 무효화

3. 비밀번호 해싱에 bcrypt 사용 (솔트 라운드: 10)
4. 환경 변수 JWT_SECRET에서 JWT 시크릿 가져오기
5. 액세스 토큰 만료: 15분
6. 리프레시 토큰 만료: 7일
7. 적절한 HTTP 상태 코드로 에러 처리 포함
8. express-validator를 사용한 입력 검증 추가
```

#### 전략 2: 컨텍스트 통합

**개선 전:**
"로그인 함수의 버그 수정해줘"

**개선 후:**
```
`src/services/auth.service.js`의 인증 문제를 디버깅하고 수정하세요:

에러 로그의 컨텍스트:
- TypeError: Cannot read property 'email' of undefined
- 사용자가 로그인 폼 제출 시 발생
- 요청 본문 구조: { username: string, password: string }

조사 단계:
1. 함수가 'email'을 예상하지만 'username'을 받는지 확인
2. user 테이블의 데이터베이스 스키마 검증
3. 요청 본문 파싱 미들웨어가 구성되어 있는지 확인
4. user 속성 접근 전 null/undefined 체크 추가

예상 수정사항:
- 프론트엔드와 백엔드 간 필드명 정렬
- 방어적 프로그래밍 체크 추가
- 일관성을 위한 변수명 업데이트
- 의미있는 에러 메시지 포함
```

#### 전략 3: 제약사항 명시

**개선 전:**
"API를 더 빠르게 만들어줘"

**개선 후:**
```
GET /api/users 엔드포인트의 API 응답 시간 최적화:

현재 상태:
- 평균 응답 시간: 3.2초
- 데이터베이스: PostgreSQL
- 현재 쿼리는 인덱스 없이 여러 JOIN 사용

목표:
- 95번째 백분위수에 대해 < 500ms로 감소
- 최대 1000개의 동시 요청 처리

최적화 체크리스트:
1. 자주 쿼리되는 컬럼에 데이터베이스 인덱스 추가
2. 5분 TTL로 Redis 캐싱 구현
3. 페이지네이션 사용 (페이지당 50개 항목)
4. N+1 쿼리를 배치 로딩으로 교체
5. 데이터베이스 쿼리 프로파일링 로그 추가
6. 쿼리 결과 메모이제이션 구현
7. 연결 풀링 사용 (풀 크기: 20)
8. 1kb 이상의 응답에 대해 압축 미들웨어 추가

성능 모니터링:
- 각 최적화 단계에 대한 타이밍 로그 추가
- Apache Bench 또는 k6로 전후 벤치마크
```

## 프롬프트 개선 템플릿

개선된 프롬프트에 이 구조를 사용하세요:

```markdown
## 작업
[명확하고 구체적인 목표]

## 컨텍스트
- 프로젝트 타입: [언어/프레임워크]
- 관련 파일: [경로]
- 현재 상태: [현재 존재하는 것]
- 종속성: [필요한 패키지/모듈]

## 요구사항
1. [승인 기준이 있는 구체적 요구사항]
2. [다른 요구사항]
...

## 기술적 제약사항
- [성능 요구사항]
- [호환성 요구사항]
- [보안 요구사항]
- [에러 처리 기대사항]

## 구현 세부사항
- 파일 위치: [생성/수정할 위치]
- 네이밍 규칙: [변수, 함수, 파일]
- 코드 스타일: [포맷팅, 따를 패턴]
- 테스트: [포함할 테스트]

## 성공 기준
- [측정 가능한 결과 1]
- [측정 가능한 결과 2]
```

## 개선을 위한 모범 사례

### 권장사항:
✓ 파일 경로를 제안하기 전에 항상 프로젝트 구조 확인
✓ 구체적인 에러 처리 요구사항 포함
✓ 관련 디자인 패턴 또는 아키텍처 원칙 언급
✓ 적절한 경우 테스트 기대사항 추가
✓ 데이터 검증 규칙 명시
✓ 인증/데이터 처리에 대한 보안 고려사항 포함
✓ 로깅/모니터링 포인트 제안
✓ 프로젝트의 기존 코드 패턴 참조

### 피해야 할 사항:
✗ 확인 없이 파일 위치 가정
✗ 간단한 작업에 불필요한 복잡성 추가
✗ 사용자의 원래 의도 무시
✗ 설명 없이 지나치게 기술적인 전문용어 사용
✗ 엣지 케이스 언급 누락
✗ 에러 처리 요구사항 생략
✗ 컨텍스트 수집 단계 건너뛰기

## 개선 워크플로우 예시

```
사용자 입력: "할일 앱 만들어줘"

1단계 - 컨텍스트 확인:
> ls -la
> cat package.json (존재하는 경우)
> 기존 React/Vue/Angular 설정 확인

2단계 - 모호성 분석:
- 어떤 프레임워크?
- 백엔드 포함?
- 데이터베이스 필요?
- 인증?
- 배포 대상?

3단계 - 개선된 프롬프트:
"기존 Next.js 14 설정을 기반으로 다음과 같은 할일 애플리케이션을 만드세요:

프론트엔드 (src/app/todos/):
- page.tsx: 서버 컴포넌트가 있는 메인 할일 목록
- components/TodoItem.tsx: 개별 할일 컴포넌트
- components/AddTodoForm.tsx: 클라이언트 측 검증이 있는 폼

백엔드 (src/app/api/todos/):
- route.ts: RESTful 엔드포인트 (GET, POST, PUT, DELETE)
- 뮤테이션을 위한 Next.js 서버 액션 사용
- 데이터 지속성을 위한 SQLite와 Prisma ORM

기능:
1. 할일 추가/편집/삭제
2. 완료/미완료 표시
3. 상태별 필터링 (전체/활성/완료)
4. 영구 저장소
5. 낙관적 UI 업데이트

데이터 모델:
```typescript
type Todo = {
  id: string;
  title: string;
  completed: boolean;
  createdAt: Date;
  updatedAt: Date;
}
```

테스트:
- 유틸리티 함수에 대한 단위 테스트
- API 라우트에 대한 통합 테스트
- Playwright를 사용한 사용자 플로우 E2E 테스트"

4단계 - 사용자에게 제시:
"요청을 분석하고 Next.js 프로젝트를 기반으로 구체적인 구현 세부사항이 포함된 개선된 프롬프트를 준비했습니다. 이 계획으로 진행하시겠습니까, 아니면 조정할 부분이 있으신가요?"
```

## Claude Code 워크플로우와의 통합

### 개선 전 체크리스트:
1. ✓ 가능한 경우 프로젝트 README 읽기
2. ✓ 언어/프레임워크 구성 파일 확인
3. ✓ 유사한 파일의 기존 코드 스타일 검토
4. ✓ 프로젝트별 패턴 또는 규칙 식별
5. ✓ CI/CD 또는 테스트 설정 확인

### 개선 후 작업:
1. 승인을 위해 개선된 프롬프트를 사용자에게 제시
2. 주요 추가사항 및 근거 설명
3. 피드백에 따라 조정 제안
4. 승인되면 구현 진행
5. 실행 전반에 걸쳐 컨텍스트 유지

## 지속적 개선

일반적인 개선 패턴 추적:
- 사용자 요청의 일반적인 모호성
- 발견된 프로젝트별 규칙
- 성공적인 개선 템플릿
- 프롬프트 품질에 대한 사용자 피드백

이 데이터를 사용하여 향후 개선사항을 다듬습니다.

---

**참고:** 이 스킬은 구현을 진행하기 전에 항상 개선된 프롬프트를 사용자와 확인해야 합니다. 목표는 요구사항을 가정하는 것이 아니라 의도를 명확히 하는 것입니다.
